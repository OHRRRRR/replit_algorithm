DP : 큰 문제를 반복되고 동일한 작은 문제로 나누어 해결하는 방법
- 관계식(점화식)을 세워보기 -> 많이 풀어봐야 함
- 풀이 보는 것을 조심하기
- 작은 문제로 나누는 이유가 큰 문제를 풀기 위함이라는 것 인지

<문제 풀이 순서>

1) 상태결정 + 직접 나열해보기
문제의 형태를 A일 때 B한 C값을 찾아라라고 바꾼 뒤,
A를 index로 잡고 생각해보자.
또한 문제에서 최종적으로 요구하는 C가 무엇인지 확인하자.

2) 점화식 만들기
문제의 형태가 A일 때 B한 C값을 찾아라일 때,
보통 B가 관계의 힌트가 된다.
또한 DP는 memoization이라고 했으므로, 특정 상태의 값을 결정할 때 이전 상태의 값을 어떻게 활용할 수 있는지 생각해보자.

3) 구현
- 탑다운 (하향식, 메모리제이션, 위 -> 아래)
맨 위의 값에서 재귀로 제일 작은 인덱스를 향하는 것
메모이제이션: 한번 계산한 결과를 메모리 공간에 메모함 -> 같은 문제 호출하면 메모한 결과 그대로 가져옴
재귀함수 사용됨

n = 5
D = [-1 for _ in range(n+3)]

def fibonacci(num):
	if D[num] != -1:
		return D[num]
	if num <= 2:
		D[num] = 1
		return D[num]

	D[num] = fibonacci(num-1) + fibonacci(num-2)
	return D[num]

print(fibonacci(n))
  
- 보텀업 (상향식, 작은문제 + 작은문제 => 큰 문제가 되는 형식) 
제일 작은 인덱스의 수 부터 목표하는 값으로 향하는 것
반복문 사용됨

n = 5
D = [-1 for _ in range(n+3)]

D[1] = 1
D[2] = 1
for i in range(3, n+1):
	D[i] = D[i-1] + D[i-2]

print(D[n])


[ 풀어본 문제 ]
beakjoon 11726
